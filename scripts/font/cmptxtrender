#!/usr/bin/python

import codecs
from palaso.font.shape import make_shaper
from optparse import OptionParser
from difflib import SequenceMatcher
from fontTools.ttLib import TTFont
import sys, os

def roundpt(pt, res) :
    try :
        return(int(pt[0] / res) * res, int(pt[1] / res) * res)
    except ValueError :
        pass
    return (0, 0)

def name(tt, gl) :
    return (tt.getGlyphName(gl[0]), roundpt(gl[1], 0.1))


def logstart(f, fpath, args) :
    f.write("""<html><head>
<meta charset="UTF8"/>
<style>
    @font-face {
        font-family: testfont;
        src: url('%s');
    }
    .text {
        font-family: testfont;
    }
    .eq {
        font-family: monospace;
        color: black;
        vertical-align: text-top;
    }
    .neq {
        font-family: monospace;
        color: red;
        vertical-align: text-top;
    }
    table, th, td {
        border-collapse: collapse;
        border: 1px solid grey;
        padding: 5px;
    }
</style></head><body><table>
""" % (fpath))
    if args.label is not None and len(args.label) :
        f.write("<tr><th></th><th></th><th>%s</th></tr>\n" % ("</th><th>".join(args.label)))

def style(g, c = 'neq') :
    return "<span class='{}'>{}:\t{}</span>".format(c, g[0], g[1])

def diffpos(l, r) :
    res = [("<span class='eq'>{}:\t(</span>".format(l[0]), "<span class='eq'>{}:\t(</span>".format(r[0]))]
    for i in range(0, 2) :
        s = ',' if i == 0 else ')'
        c = 'eq' if l[1][i] == r[1][i] else 'neq'
        u = []
        for t in (l[1][i], r[1][i]) :
            u.append("<span class='{}'>{:.17g}</span>{}".format(c, t, s))
        res.append(u)
    return map(lambda x: "".join(x), zip(*res))

def logentry(f, line, word, string, lglyphs, rglyphs) :
    f.write("  <tr><td>%d.%d</td><td class='text'>%s</td>\n" %
                (line, word, string))
    def getname(t) :
        return str(t[0])
    s = SequenceMatcher(None, map(getname, lglyphs), map(getname, rglyphs))
    info = []
    for o in s.get_opcodes() :
        if o[0] == 'insert' :
            for i in range(o[3], o[4]) :
                info.append(('', style(rglyphs[i])))
        elif o[0] == 'delete' :
            for i in range(o[1], o[2]) :
                info.append((style(lglyphs[i]), ''))
        elif o[0] == 'replace' :
            for i in range(o[1], o[2]) :
                info.append((style(lglyphs[i]), style(rglyphs[i-o[1]+o[3]]) if i-o[1]+o[3] < o[4] else ''))
            for i in range(o[3] + o[2] - o[1], o[4]) :
                info.append(('', style(rglyphs[i])))
        else :
            for i in range(o[1], o[2]) :
#                info.append((style(lglyphs[i], 'eq'), style(rglyphs[i-o[1]+o[3]], 'eq')))
                info.append(diffpos(lglyphs[i], rglyphs[i-o[1]+o[3]]))
    for inf in zip(*info) :
        f.write("    <td class='eq'>%s</td>\n" % ("<br/>".join(inf)))
    f.write("  </tr>\n")

def logend(f) :
    f.write("</body></html>\n");

parser = OptionParser(usage = '''%prog [options] infont1 infont2

If the first font is above the output file in the filesystem hierarchy, it may not load.
On firefox, ensure that the configuration option security.fileuri.strict_origin_policy
is set to false to allow locally loaded html files to access fonts anywhere on the
local filesystem.''')
parser.add_option("-t","--text",help="text file to test each line from")
parser.add_option("-o","--output",help="file to log results to")
parser.add_option("-f","--feat",action="append",help="id=value pairs, may be repeated")
parser.add_option("-e","--engine",default='gr',help="renderer to use [gr]")
parser.add_option("-l","--lang",help="language to tag text with")
parser.add_option("-s","--script",help="script of text")
parser.add_option("-r","--rtl",action="store_true",help="right to left")
parser.add_option("-k","--keep",action="store_true",help="keep going, don't return error count")
parser.add_option("-p","--split",action="store_true",help="Split on spaces")
parser.add_option("-L","--label",action="append",help="report font labels")
(opts, args) = parser.parse_args()

if not opts.lang : opts.lang = 0
if not opts.script : opts.script = 0
if not opts.rtl : opts.rtl = 0
if opts.output :
    outfile = codecs.open(opts.output, mode="w", encoding="utf_8")
else :
#    outfile = codecs.EncodedFile(sys.stdout, "unicode_internal", file_encoding="utf_8")
    outfile = codecs.getwriter("utf_8")(sys.stdout)

feats = {}
if opts.feat :
    for f in opts.feat :
        k, v = f.split('=')
        feats[k.strip()] = int(v.strip())

font1 = make_shaper(opts.engine, args[0], 12, opts.rtl, feats, opts.script, opts.lang)
fpath1 = os.path.relpath(args[0], start=(os.path.dirname(opts.output) if opts.output else '.'))
tt1 = TTFont(args[0])
if len(args) > 1 :
    font2 = make_shaper(opts.engine, args[1], 12, opts.rtl, feats, opts.script, opts.lang)
    tt2 = TTFont(args[1])
f = codecs.open(opts.text, encoding="utf_8")

count = 0
errors = 0
logstarted = False
for l in f.readlines() :
    count += 1
    l = l.strip()
    if opts.split :
        words = l.split()
    else :
        words = (l, )
    wcount = 0
    for s in words :
        wcount += 1
        gl1 = map(lambda x: name(tt1, x), font1.glyphs(s))
        if len(args) > 1 :
            gl2 = map(lambda x: name(tt2, x), font2.glyphs(s))
        else :
            gl2 = []
        if gl1 != gl2 :
            if not logstarted :
                logstart(outfile, fpath1, opts)
                logstarted = True
            logentry(outfile, count, wcount, s, gl1, gl2)
            errors += 1
if logstarted : logend(outfile)
outfile.close()
sys.exit(0 if opts.keep else errors)

