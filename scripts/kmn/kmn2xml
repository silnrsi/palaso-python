#!/usr/bin/python
'''
Generate an XML file from an keyman keyboard which describes what 
characters are output for every key (shifted and unshifted) on an standard
105 key keyboard.
NOTE: This will not generate mappings key sequences, dead-keys or keys in 
combination with meta keys other than shift.
'''
__version__ = '1.2'
__date__    = '25 September 2009'
__author__  = 'Tim Eves <tim_eves@sil.org>'
__credits__ = '''\
Martin Hosken for the original Perl implementation of this script. 
This version uses libkmflcomp to process the source rather than parse the 
source directly so it works better with more complex keyboards.
'''

import codecs, optparse, sys
from palaso.kmfl import kmfl
from palaso import kmn
from htmlentitydefs import codepoint2name


key_tops  = r'''`1234567890-=QWERTYUIOP[]\ASDFGHJKL;'ZXCVBNM,./'''
shifted   = r'''~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:"ZXCVBNM<>?'''
unshifted = r'''`1234567890-=qwertyuiop[]\asdfghjkl;'zxcvbnm,./'''

xmlentities = { "<" : '&lt;', '&' : '&amp;', '>' : '&gt;', '"' : '&quot;', "'" : '&apos;' }

outformats = {
    'kmxml' : {
        'header' : u'''\
<?xml version='1.0' encoding='UTF-8'?>
<keyboard font='{font}' size='{size}' modifiers='{modifiers}' name='{name}'>
'''.format,
        'key' : u'''\
    <key id=\"{0}\" unshift='{1}' shift='{2}'/>
'''.format,
        'footer' : u'''</keyboard>''',
        'prep' : lambda x : " ".join(map(quote, x)),
        'bytes' : lambda x : x},

    'utr22' : {
        'header' : u'''\
<?xml version='1.0' encoding='UTF-8'?>
<characterMapping
    id=""
    version="1"
    description=""
    contact=""
    registrationAuthority="none"
    registrationName=""
    unicode-font="{font}"
    normalization="none"
>

<history>
    <modified version="1" date="">
        autogenerated from {name}
    </modified>
</history>

<assignments sub="2F">
    <range bFirst="00" bLast="1F" uFirst="0000" uLast="001F"/>

'''.format,
        'key' : u'''\
    <a b="{3}" u="{1}"/>
    <a b="{4}" u="{2}"/>
'''.format,
        'footer' : u'''
</assignments>
</characterMapping>
''',
        'prep' : lambda x : " ".join(map(lambda y: "{0:04X}".format(ord(y)), x)),
        'bytes' : lambda x : hex(ord(x))[2:].upper()}}


def quote(cs):
    r = u''
    for c in cs:
        ent = xmlentities.get(c)
        r += (ent if ent else c)
    return r


def output_chars(keypresses):
    #return [kb.run_items([it]) or ' ' for it in kmn.keysyms_items(keypresses)]
    res = []
    for it in keypresses :
        r = kb.run_items([kmn.keysym_item(kmn.char_keysym(it))])
        res.append(r)
    return res

def output_modified_chars(keytops, mod) :
    res = []
    if mod.upper().endswith("ALT") or mod.upper().endswith("CTRL") :
        keys = map(lambda x : "[{0} {1}]".format(mod, kmn.char_keysym(x)[1:-1]), keytops.replace(r'\\', '\\'))
        for it in keys :
            k = kmn.keysym_item(kmn.char_keysym(it))
            r = kb.run_items([k])
            res.append(r)
    else :
        modsym = kmn.keysym_item(mod)
        for it in keytops :
            r = kb.run_items([modsym, kmn.keysym_item(kmn.char_keysym(it))])
            res.append(r)
    return res
#    return [quote(kb.run_items([kmn.keysym_item(it)])) for it in keys]

parser = optparse.OptionParser(usage='%prog [options] <KEYMAN FILE>\n' + __doc__)
parser.add_option("-f","--font",action='store',metavar='FONTNAME',
                  help='Specify the preferred font for the keyboard output')
parser.add_option("-s","--size",action='store',type="float", metavar='POINTS',
                  help='The size of the output characters')
parser.add_option("-m","--modifiers",action="store",help="Modifiers to apply to keytops")
parser.add_option("-l","--lang",action="store",help="xml output language [kmxml]")

(opts,kmns) = parser.parse_args()
if not opts.lang : opts.lang = "kmxml"

of = outformats[opts.lang]
if len(kmns) == 0:
    sys.stderr.write(parser.expand_prog_name('%prog: missing KEYMAN FILE\n'))
    parser.print_help(file=sys.stderr)
    sys.exit(1)

kb = kmfl(kmns[0])
out = codecs.getwriter('utf_8')(sys.stdout)
out.write(of['header'](font=opts.font or '', 
                 size=opts.font and opts.size or '',
                 name=kb.store('NAME'),
                 modifiers=opts.modifiers or ''))
if opts.modifiers :
    out.writelines(map(of['key'], key_tops, map(of['prep'], output_modified_chars(unshifted, opts.modifiers)),
                            map(of['prep'], output_modified_chars(shifted, opts.modifiers)), map(of['bytes'], shifted), map(of['bytes'], unshifted)))
else :
    out.writelines(map(outformats[opts.lang]['key'], key_tops, map(of['prep'], output_chars(unshifted)), map(of['prep'], output_chars(shifted)), map(of['bytes'], unshifted), map(of['bytes'], shifted)))
out.write(of['footer'])
